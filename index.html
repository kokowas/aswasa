<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÿ™ÿ™ÿ®ÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿ®ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ®</title>
    <style>
        /* Base styles for full page and no scrolling - Reverted to original user's intent */
        html, body {
            margin: 0;
            padding: 0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Reverted to original flex-start */
            min-height: 100vh; /* Reverted to original min-height for responsiveness */
            margin: 0;
            padding: 20px; /* Reverted to original padding */
            background-color: white;
            text-align: center;
            box-sizing: border-box; /* Keep border-box for consistent padding */
        }
        h1 {
            color: #333;
            margin-top: 0;
            margin-bottom: 15px;
        }
        #svg-container {
            position: relative;
            width: 100%;
            border: 3px solid #333;
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            touch-action: none; /* Crucial for preventing default touch scroll/zoom on SVG */
            background-color: white;
            overflow: hidden; /* Keep to clip drawing outside letter boundaries */
            transition: all 0.3s ease-in-out; /* For smooth viewBox transitions */
            display: block;
            height: auto; /* Allow height to adjust based on content/SVG */
        }

        /* Responsive SVG specific styles - KEY CHANGE for scaling */
        #svg {
            display: block;
            width: 100%;
            height: auto; /* This is the key for maintaining aspect ratio and proper scaling */
            cursor: crosshair;
            transition: all 0.3s ease-in-out; /* Smooth viewBox transitions */
        }

        .buttons {
            margin-top: 25px; /* Reverted to original margin */
            display: flex;
            gap: 15px; /* Reverted to original gap */
            justify-content: center;
            flex-wrap: wrap;
            align-items: center;
            padding: 0; /* Reverted padding */
        }
        button {
            padding: 12px 25px; /* Reverted to original padding */
            font-size: 18px; /* Reverted to original font size */
            cursor: pointer;
            border: 2px solid #333;
            border-radius: 8px;
            background-color: #fff;
            font-weight: bold;
            transition: all 0.2s;
            white-space: nowrap;
            margin: 5px;
        }
        button:hover { background-color: #e9e9e9; }
        button:active { transform: scale(0.95); }
        button:disabled {
            cursor: not-allowed;
            background-color: #ccc;
        }
        #guide-dot {
            pointer-events: none;
            display: block;
        }

        /* --- Zoom Controls CSS --- */
        #zoom-icon {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 40px;
            height: 40px;
            font-size: 20px;
            line-height: 1;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid #ccc;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            color: #333;
            z-index: 10;
            transition: background-color 0.2s;
        }
        #zoom-icon.zoomed {
            background-color: #e9e9e9;
        }
        #zoom-icon.hidden {
            display: none;
        }

        #zoom-adjust-controls {
            position: absolute;
            top: 60px;
            left: 10px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        #zoom-adjust-controls.hidden {
            display: none;
        }
        #zoom-adjust-controls button {
            width: 35px;
            height: 35px;
            font-size: 24px;
            font-weight: bold;
            line-height: 1;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid #ccc;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            color: #333;
        }
        #zoom-adjust-controls button:hover {
            background-color: white;
        }
        #zoom-adjust-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* --- Applause Effect (Confetti) Styles --- */
        #confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            opacity: 0;
            z-index: 1000;
            overflow: hidden;
            transition: opacity 0.5s ease-out;
            background-color: transparent;
        }
        #confetti-container.visible {
            opacity: 1;
        }

        #applause-message {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 1em;
            color: forestgreen;
            font-weight: bold;
            text-shadow: 2px 2px 3px rgba(0,0,0,0.5);
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.5s ease-out;
            pointer-events: none;
        }
        #applause-message.visible {
            opacity: 1;
        }

        .confetti-piece {
            position: absolute;
            background-color: currentColor;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            opacity: 0;
            animation: confetti-fall 3s ease-out forwards;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Specific styles for audio icon buttons */
        button.audio-icon-button {
            width: 50px;
            height: 50px;
            padding: 0;
            font-size: 24px;
            border-radius: 50%;
            background-color: #f0f0f0;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #333;
            line-height: 1;
            flex-shrink: 0;
            margin: 5px;
        }

        button.audio-icon-button:hover {
            background-color: #e0e0e0;
            transform: scale(1.05);
        }

        button.audio-icon-button:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <h1>ÿ™ÿ™ÿ®ÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿ®ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ®!</h1>
    <div id="svg-container">
        <!-- Zoom controls -->
        <button id="zoom-icon" aria-label="ÿ™ŸÉÿ®Ÿäÿ±/ÿ™ÿµÿ∫Ÿäÿ±">üîç</button>
        <div id="zoom-adjust-controls" class="hidden">
            <button id="zoom-in-adjust-button" title="ÿ™ŸÉÿ®Ÿäÿ± ÿ£ŸÉÿ´ÿ±">+</button>
            <button id="zoom-out-adjust-button" title="ÿ™ÿµÿ∫Ÿäÿ± ÿ£ŸÉÿ´ÿ±">-</button>
        </div>

        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1280 720">
            <defs>
                <clipPath id="letter-mask">
                    <path d="M815.041 121C820.969 139.25 825.148 161.074 827.58 186.473 829.1 202.289 830.62 239.702 832.139 298.711 834.875 325.783 838.827 343.12 843.994 350.724 848.25 357.112 852.885 360.306 857.901 360.306L873.686 360.306 889.818 360.306 1059.49 360.306C1043.99 348.291 1030.91 338.938 1020.28 332.246 1007.05 323.881 994.97 317.798 984.027 313.996 971.717 309.737 959.254 307.608 946.639 307.608 938.888 307.608 931.061 308.141 923.157 309.205 927.565 297.951 933.34 288.902 940.484 282.058 950.819 272.173 963.889 267.23 979.696 267.23 995.198 267.23 1013.51 274.834 1034.64 290.043 1045.13 297.647 1062.22 312.095 1085.93 333.387 1104.32 349.964 1116.79 358.937 1123.32 360.306L1137 360.306 1137 400 889.818 400 873.686 400 857.901 400C847.566 400 839.283 395.818 833.051 387.453 827.58 380.153 823.438 369.279 820.627 354.831 817.815 340.383 815.649 322.589 814.129 301.449 813.217 284.263 812.267 266.621 811.279 248.523 810.292 230.425 809 216.699 807.404 207.346 805.808 197.993 803.642 190.351 800.907 184.419 797.563 177.119 792.927 170.732 787 165.257L815.041 121Z"/>
                    <path d="M744.443 267C756.886 278.55 766.067 290.099 771.985 301.649 778.662 314.719 782 329.308 782 345.416L782 400.81C782 417.526 774.868 434.851 760.604 452.783 748.161 468.588 732.683 482.19 714.17 493.587 696.568 504.529 682.077 510 670.696 510 660.225 510 648.921 508.48 636.781 505.441 627.525 503.161 616.447 499.59 603.549 494.727 592.624 490.624 581.774 486.521 571 482.417L574.87 473.299C584.885 475.275 595.317 477.288 606.167 479.34 617.016 481.392 626.842 482.417 635.643 482.417 655.066 482.417 675.324 476.187 696.416 463.725 715.536 452.327 731.849 437.928 745.354 420.528 758.859 403.127 765.612 387.436 765.612 373.455 765.612 361.449 762.121 348.836 755.141 335.614 749.527 324.977 741.636 314.035 731.469 302.789L744.443 267Z"/>
                    <path d="M396.417 271C404.009 283.427 409.172 294.414 411.906 303.961 415.702 317.449 417.6 335.861 417.6 359.199L445.617 359.199C460.043 359.199 470.293 357.002 476.367 352.607 481.681 348.819 484.339 342.984 484.339 335.104 484.339 330.709 484.073 326.276 483.542 321.806 483.01 317.335 482.213 312.448 481.15 307.144L490.261 293.504 493.906 315.554C497.246 330.406 501.726 341.09 507.344 347.606 513.57 354.88 522.378 358.517 533.767 358.517 537.259 358.517 539.955 357.419 541.853 355.221 543.751 353.024 544.7 350.258 544.7 346.924 544.7 339.347 542.346 331.239 537.639 322.601 534.146 316.236 529.515 309.871 523.744 303.506L539.005 278.729C546.143 290.398 550.470 298.354 551.989 302.597 555.330 312.145 557 326.011 557 344.196L557 398.753 539.005 398.753C529.894 398.753 521.884 397.503 514.975 395.002 508.066 392.502 501.043 388.523 493.906 383.068 487.528 388.826 481.833 392.691 476.822 394.661 469.685 397.389 459.283 398.753 445.617 398.753L417.6 398.753C417.6 412.695 414.259 426.258 407.578 439.443 398.922 456.567 385.711 470.131 367.944 480.133 345.622 492.711 317.681 499 284.122 499 253.752 499 230.518 493.696 214.422 483.088 196.807 471.419 188 453.536 188 429.441 188 416.408 189.594 403.223 192.783 389.887 195.972 376.551 200.3 363.140 205.767 349.652 209.107 341.469 214.878 328.890 223.078 311.917L232.189 316.009C221.559 337.831 214.536 355.032 211.119 367.61 207.703 380.188 205.994 391.706 205.994 402.163 205.994 420.954 212.714 435.237 226.153 445.012 239.592 454.787 258.763 459.674 283.667 459.674 312.822 459.674 338.865 454.597 361.794 444.444 390.342 431.865 404.617 414.286 404.617 391.706 404.617 376.551 401.807 362.155 396.189 348.515 391.785 337.756 385.559 327.451 377.511 317.6L396.417 271Z"/>
                </clipPath>

                <!-- TRACING GUIDE PATHS (INVISIBLE) -->
                <g id="trace-guides" style="display: none;">
                    <path id="trace-path-0" d="M931.786 302.789C935.876 299.84 941.827 290.547 951.417 288.638 961.007 286.728 975.9 286.504 989.325 291.333 1002.75 296.162 1017.87 306.495 1031.97 317.613 1046.07 328.732 1068.15 346.368 1084.65 356.891 1101.16 367.415 1127.48 376.858 1131 380.756 1129.87 381.542 1124.52 380.023 1105.76 380.281L1018.43 382.303 907.417 382.303C879.662 381.404 868.695 385.017 851.619 381.235 835.603 377.688 832.684 348.769 827.543 325.026 822.401 301.282 822.462 259.325 820.769 238.773 818.174 207.102 815.41 156.619 814 135"/>
                    <path id="trace-path-1" d="M744.232 284C745.524 286.364 759.854 310.013 764.785 326.672 769.716 343.331 775.068 366.128 773.815 383.955 772.563 401.783 766.862 418.738 757.271 433.637 747.680 448.535 734.003 462.962 716.268 473.346 698.534 483.73 674.073 494.863 650.862 495.943 627.651 497.022 586.281 482.542 577 479.824"/>
                    <path id="trace-path-2" d="M535.137 288.283C537.275 295.574 541.580 309.688 545.401 323.281 550.749 342.305 550.678 370.356 541.492 372.76 524.350 377.246 511.039 371.553 501.929 360.088 492.820 348.623 489.250 308.497 486.835 303.972 484.420 299.446 486.548 321.574 487.439 332.935 488.522 346.751 485.359 365.191 473.539 371.043 461.720 376.894 428.009 377.339 416.523 368.044 405.037 358.750 408.106 329.615 404.622 315.275 401.138 300.934 396.829 281.9 395.621 282 394.414 282.101 390.655 295.707 392.758 311.592 394.861 327.478 406.648 360.125 408.238 377.313 409.829 394.501 408.242 415.201 398.672 430.543 389.101 445.885 370.781 461.651 350.818 469.366 332.441 476.468 314.244 477.803 290.770 478.809 265.378 479.897 231.159 476.626 216.139 461.565 201.118 446.505 196.024 414.726 200.646 388.448 204.865 364.460 220.761 330.908 226.054 315.766"/>
                </g>
            </defs>

            <!-- SEMI-TRANSPARENT LETTER GUIDES (BACKGROUND) -->
            <g id="guides" fill="#CCCCCC" fill-opacity="1">
                <!-- These paths define the visible grey letters -->
                <path d="M815.041 121C820.969 139.25 825.148 161.074 827.58 186.473 829.1 202.289 830.62 239.702 832.139 298.711 834.875 325.783 838.827 343.12 843.994 350.724 848.25 357.112 852.885 360.306 857.901 360.306L873.686 360.306 889.818 360.306 1059.49 360.306C1043.99 348.291 1030.91 338.938 1020.28 332.246 1007.05 323.881 994.97 317.798 984.027 313.996 971.717 309.737 959.254 307.608 946.639 307.608 938.888 307.608 931.061 308.141 923.157 309.205 927.565 297.951 933.34 288.902 940.484 282.058 950.819 272.173 963.889 267.23 979.696 267.23 995.198 267.23 1013.51 274.834 1034.64 290.043 1045.13 297.647 1062.22 312.095 1085.93 333.387 1104.32 349.964 1116.79 358.937 1123.32 360.306L1137 360.306 1137 400 889.818 400 873.686 400 857.901 400C847.566 400 839.283 395.818 833.051 387.453 827.58 380.153 823.438 369.279 820.627 354.831 817.815 340.383 815.649 322.589 814.129 301.449 813.217 284.263 812.267 266.621 811.279 248.523 810.292 230.425 809 216.699 807.404 207.346 805.808 197.993 803.642 190.351 800.907 184.419 797.563 177.119 792.927 170.732 787 165.257L815.041 121Z"/>
                <path d="M744.443 267C756.886 278.55 766.067 290.099 771.985 301.649 778.662 314.719 782 329.308 782 345.416L782 400.81C782 417.526 774.868 434.851 760.604 452.783 748.161 468.588 732.683 482.19 714.17 493.587 696.568 504.529 682.077 510 670.696 510 660.225 510 648.921 508.48 636.781 505.441 627.525 503.161 616.447 499.59 603.549 494.727 592.624 490.624 581.774 486.521 571 482.417L574.87 473.299C584.885 475.275 595.317 477.288 606.167 479.34 617.016 481.392 626.842 482.417 635.643 482.417 655.066 482.417 675.324 476.187 696.416 463.725 715.536 452.327 731.849 437.928 745.354 420.528 758.859 403.127 765.612 387.436 765.612 373.455 765.612 361.449 762.121 348.836 755.141 335.614 749.527 324.977 741.636 314.035 731.469 302.789L744.443 267Z"/>
                <path d="M396.417 271C404.009 283.427 409.172 294.414 411.906 303.961 415.702 317.449 417.6 335.861 417.6 359.199L445.617 359.199C460.043 359.199 470.293 357.002 476.367 352.607 481.681 348.819 484.339 342.984 484.339 335.104 484.339 330.709 484.073 326.276 483.542 321.806 483.01 317.335 482.213 312.448 481.15 307.144L490.261 293.504 493.906 315.554C497.246 330.406 501.726 341.09 507.344 347.606 513.57 354.88 522.378 358.517 533.767 358.517 537.259 358.517 539.955 357.419 541.853 355.221 543.751 353.024 544.7 350.258 544.7 346.924 544.7 339.347 542.346 331.239 537.639 322.601 534.146 316.236 529.515 309.871 523.744 303.506L539.005 278.729C546.143 290.398 550.470 298.354 551.989 302.597 555.330 312.145 557 326.011 557 344.196L557 398.753 539.005 398.753C529.894 398.753 521.884 397.503 514.975 395.002 508.066 392.502 501.043 388.523 493.906 383.068 487.528 388.826 481.833 392.691 476.822 394.661 469.685 397.389 459.283 398.753 445.617 398.753L417.6 398.753C417.6 412.695 414.259 426.258 407.578 439.443 398.922 456.567 385.711 470.131 367.944 480.133 345.622 492.711 317.681 499 284.122 499 253.752 499 230.518 493.696 214.422 483.088 196.807 471.419 188 453.536 188 429.441 188 416.408 189.594 403.223 192.783 389.887 195.972 376.551 200.3 363.140 205.767 349.652 209.107 341.469 214.878 328.890 223.078 311.917L232.189 316.009C221.559 337.831 214.536 355.032 211.119 367.61 207.703 380.188 205.994 391.706 205.994 402.163 205.994 420.954 212.714 435.237 226.153 445.012 239.592 454.787 258.763 459.674 283.667 459.674 312.822 459.674 338.865 454.597 361.794 444.444 390.342 431.865 404.617 414.286 404.617 391.706 404.617 376.551 401.807 362.155 396.189 348.515 391.785 337.756 385.559 327.451 377.511 317.6L396.417 271Z"/>
                </g>
            </defs>

            <!-- USER DRAWING LAYER (CLIPPED) -->
            <g clip-path="url(#letter-mask)">
                <path id="drawing-path" stroke="#0000FF" stroke-width="60" stroke-linecap="round" stroke-linejoin="round" fill="none" />
            </g>

            <!-- ANIMATION GUIDE DOT (ON TOP) -->
            <circle id="guide-dot" cx="0" cy="0" r="15" fill="#E74C3C" stroke="white" stroke-width="3" />
        </svg>
    </div>

    <div class="buttons">
        <button id="toggleTracingSoundButton" class="audio-icon-button" aria-label="ŸÉÿ™ŸÖ ÿµŸàÿ™ ÿßŸÑÿ™ÿ™ÿ®ÿπ">üîä</button>
        <button id="playWordAudioButton" class="audio-icon-button" aria-label="ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿßŸÑŸÉŸÑŸÖÿ©">‚ñ∂Ô∏è</button>
        <button id="demo-button">ÿπÿ±ÿ∂ ÿ™Ÿàÿ∂Ÿäÿ≠Ÿä</button>
        <button id="clear-button">ŸÖÿ≥ÿ≠ ÿßŸÑÿ±ÿ≥ŸÖ</button>
    </div>

    <!-- Applause Effect Elements -->
    <div id="confetti-container"></div>
    <div id="applause-message"></div>

    <script>
        const svgContainer = document.getElementById('svg-container');
        const svg = document.querySelector('svg');
        const drawingPath = document.getElementById('drawing-path');
        const demoButton = document.getElementById('demo-button');
        const clearButton = document.getElementById('clear-button');
        const guideDot = document.getElementById('guide-dot');
        const traceGuides = Array.from(document.querySelectorAll('#trace-guides path'));

        // Zoom Elements
        const zoomIcon = document.getElementById('zoom-icon');
        const zoomAdjustControls = document.getElementById('zoom-adjust-controls');
        const zoomInAdjustButton = document.getElementById('zoom-in-adjust-button');
        const zoomOutAdjustButton = document.getElementById('zoom-out-adjust-button');

        // Applause Effect Elements
        const confettiContainer = document.getElementById('confetti-container');
        const applauseMessage = document.getElementById('applause-message');

        // New Buttons - Adjusted to reference their new class and purpose
        const toggleTracingSoundButton = document.getElementById('toggleTracingSoundButton');
        const playWordAudioButton = document.getElementById('playWordAudioButton');

        // Audio Elements
        let tracingSound;
        try {
            tracingSound = new Audio('sounds/coco2.mp3');
            tracingSound.loop = true;
            tracingSound.volume = 0.5;
            tracingSound.addEventListener('error', (e) => {
                console.error('Error loading tracing sound:', tracingSound.src, e);
            });
        } catch (e) {
            console.error("Failed to create Audio object for tracing sound (check path/file):", e);
        }

        let completionSound;
        try {
            completionSound = new Audio('sounds/congra.mp3');
            completionSound.volume = 0.7;
            completionSound.addEventListener('error', (e) => {
                console.error('Error loading completion sound:', completionSound.src, e);
            });
        } catch (e) {
            console.error("Failed to create Audio object for completion sound (check path/file):", e);
        }

        let wordAudio;
        try {
            wordAudio = new Audio('sounds/animal.mp3');
            wordAudio.volume = 0.8;
            wordAudio.addEventListener('error', (e) => {
                console.error('Error loading word audio:', wordAudio.src, e);
            });
        } catch (e) {
            console.error("Failed to create Audio object for word audio (check path/file):", e);
        }

        // Initial setup for audio buttons (icons and aria-labels)
        if (toggleTracingSoundButton && tracingSound) {
            toggleTracingSoundButton.innerHTML = 'üîä';
            toggleTracingSoundButton.setAttribute('aria-label', 'ŸÉÿ™ŸÖ ÿµŸàÿ™ ÿßŸÑÿ™ÿ™ÿ®ÿπ');
        }
        if (playWordAudioButton && wordAudio) {
            playWordAudioButton.innerHTML = '‚ñ∂Ô∏è';
            playWordAudioButton.setAttribute('aria-label', 'ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿßŸÑŸÉŸÑŸÖÿ©');
        }

        // Event listener for completion sound to play word audio and update icon
        if (completionSound && wordAudio) {
            completionSound.addEventListener('ended', () => {
                if (wordAudio.readyState >= 2) {
                    wordAudio.currentTime = 0;
                    wordAudio.play().then(() => {
                        playWordAudioButton.innerHTML = '‚è∏Ô∏è';
                        playWordAudioButton.setAttribute('aria-label', 'ÿ•ŸäŸÇÿßŸÅ ÿµŸàÿ™ ÿßŸÑŸÉŸÑŸÖÿ© ŸÖÿ§ŸÇÿ™Ÿãÿß');
                    }).catch(e => console.error("Error playing word audio after completion sound:", e));
                } else {
                    console.warn("Word audio not ready to play after completion sound. ReadyState:", wordAudio.readyState);
                }
            });
        }


        let isDrawing = false;
        let guideDotAnimationId = null; // Main rAF loop ID

        let currentPathIndex = 0;
        let pathProgress = Array(traceGuides.length).fill(0);
        let tolerance = 40;

        let dotAnimationStartTime = null;
        const dotAnimationDuration = 4000;

        let drawingNeedsUpdate = false; // Flag to indicate drawing path needs DOM update

        // Zoom Variables
        let isZoomed = false;
        const defaultViewBox = "0 0 1280 720";
        let originalViewBox = defaultViewBox;
        let initialZoomViewBox = null;
        let zoomOutStep = 0;
        const TOTAL_ZOOM_OUT_STEPS = 8;
        const ZOOM_PADDING = 250;
        const ZOOM_IN_ICON = 'üîç';
        const ZOOM_OUT_ICON = 'üîé';

        // SVG Utility for coordinates
        let svgPoint = svg.createSVGPoint();
        let svgCTM = null;

        // Initialize path lengths
        const pathLengths = traceGuides.map(path => path.getTotalLength());

        // --- Utility Functions ---
        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        function isValidNumber(value) {
            return typeof value === 'number' && isFinite(value);
        }

        function getSVGCoordinates(event) {
            if (!svgPoint || !svg) return { x: -1, y: -1 };
            const pt = svgPoint;
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            pt.x = clientX;
            pt.y = clientY;
            try {
                // We only need to update svgCTM when the viewBox changes or on window resize.
                // For performance, cache it and re-calculate only when necessary.
                if (!svgCTM) {
                    svgCTM = svg.getScreenCTM();
                }
                if (!svgCTM) { // Fallback if still null
                    console.warn("SVG CTM is null or undefined.");
                    return { x: -1, y: -1 };
                }
                return pt.matrixTransform(svgCTM.inverse());
            } catch (e) {
                console.warn("Error getting SVG CTM:", e);
                return { x: -1, y: -1 };
            }
        }

        function getClosestPointOnGuidePath(userPoint, pathElement, startLength, endLength) {
            let minDistance = Infinity;
            let closestPoint = null;
            let closestLength = startLength;
            const step = 5;

            for (let l = startLength; l <= endLength; l += step) {
                const pathPoint = pathElement.getPointAtLength(l);
                const distance = Math.sqrt(
                    Math.pow(userPoint.x - pathPoint.x, 2) +
                    Math.pow(userPoint.y - pathPoint.y, 2)
                );

                if (distance < minDistance) {
                    minDistance = distance;
                    closestPoint = pathPoint;
                    closestLength = l;
                }
            }
            return { point: closestPoint, length: closestLength, distance: minDistance };
        }

        function getFullDrawingPathData() {
            let fullPath = '';
            for (let i = 0; i < traceGuides.length; i++) {
                if (pathProgress[i] > 0) {
                    fullPath += getPathSegment(traceGuides[i], 0, pathProgress[i]) + ' ';
                }
            }
            return fullPath.trim();
        }

        function getPathSegment(path, from, to) {
            if (from >= to) return '';

            const p = path.getPointAtLength(from);
            let data = `M ${p.x} ${p.y}`;
            const step = 5;
            for (let i = from + step; i <= to; i += step) {
                const p2 = path.getPointAtLength(i);
                data += ` L ${p2.x} ${p2.y}`;
            }
            return data;
        }

        // --- Zoom Related Functions ---
        function updateZoomAdjustButtonsState() {
            if (!isZoomed) return;
            zoomInAdjustButton.disabled = (zoomOutStep <= 0);
            zoomOutAdjustButton.disabled = (zoomOutStep >= TOTAL_ZOOM_OUT_STEPS);
        }

        function adjustZoom(direction) {
            if (!isZoomed || !svg) return;

            if (direction === 'in') {
                zoomOutStep = Math.max(0, zoomOutStep - 1);
            } else {
                zoomOutStep = Math.min(TOTAL_ZOOM_OUT_STEPS, zoomOutStep + 1);
            }

            if (zoomOutStep >= TOTAL_ZOOM_OUT_STEPS) {
                zoomOut();
                return;
            } else if (zoomOutStep <= 0) {
                zoomToStroke(currentPathIndex, false);
                return;
            }

            try {
                const startVB = initialZoomViewBox.split(' ').map(Number);
                const endVB = originalViewBox.split(' ').map(Number);

                const fraction = zoomOutStep / TOTAL_ZOOM_OUT_STEPS;

                const newX = lerp(startVB[0], endVB[0], fraction);
                const newY = lerp(startVB[1], endVB[1], fraction);
                const newWidth = lerp(startVB[2], endVB[2], fraction);
                const newHeight = lerp(startVB[3], endVB[3], fraction);

                svg.style.transition = 'none';
                svg.setAttribute('viewBox', `${newX} ${newY} ${newWidth} ${newHeight}`);
                setTimeout(() => {
                    svg.style.transition = '';
                    updateZoomAdjustButtonsState();
                    svgCTM = svg.getScreenCTM(); // Update CTM after viewBox change
                }, 50);
            } catch (e) {
                console.error("Could not adjust zoom:", e);
            }
        }

        function calculateZoomViewBox(targetIndex) {
            if (targetIndex >= traceGuides.length || !traceGuides[targetIndex]) return null;
            try {
                const path = traceGuides[targetIndex];
                const bbox = path.getBBox();
                const minDim = 50;
                const safeWidth = Math.max(bbox.width, minDim);
                const safeHeight = Math.max(bbox.height, minDim);
                const centerX = bbox.x + bbox.width / 2;
                const centerY = bbox.y + bbox.height / 2;
                const newWidth = safeWidth + 2 * ZOOM_PADDING;
                const newHeight = safeHeight + 2 * ZOOM_PADDING;
                const newX = centerX - newWidth / 2;
                const newY = centerY - newHeight / 2;
                return `${newX} ${newY} ${newWidth} ${newHeight}`;
            } catch (e) {
                console.error("Error calculating zoom viewBox for index", targetIndex, ":", e);
                return null;
            }
        }

        function zoomToStroke(targetIndex, instant = false) {
            const newViewBox = calculateZoomViewBox(targetIndex);
            if (!newViewBox) {
                zoomOut(instant);
                return;
            }

            initialZoomViewBox = newViewBox;
            zoomOutStep = 0;

            isZoomed = true;
            svgContainer.classList.add('zoomed-in');
            zoomAdjustControls.classList.remove('hidden');
            if (instant) svg.style.transition = 'none';
            svg.setAttribute('viewBox', newViewBox);
            setTimeout(() => {
                if (instant) svg.style.transition = '';
                svgCTM = svg.getScreenCTM(); // Update CTM after viewBox change
                updateZoomIconPositionAndVisibility();
                updateZoomAdjustButtonsState();
            }, instant ? 10 : 350);
        }

        function zoomOut(instant = false) {
            if (!originalViewBox) return;
            isZoomed = false;
            svgContainer.classList.remove('zoomed-in');
            zoomAdjustControls.classList.add('hidden');
            initialZoomViewBox = null;
            zoomOutStep = 0;

            if (instant) svg.style.transition = 'none';
            svg.setAttribute('viewBox', originalViewBox);
            setTimeout(() => {
                if (instant) svg.style.transition = '';
                svgCTM = svg.getScreenCTM(); // Update CTM after viewBox change
                updateZoomIconPositionAndVisibility();
            }, instant ? 10 : 350);
        }

        function updateZoomIconPositionAndVisibility() {
            if (!zoomIcon) return;
            const shouldShow = traceGuides.length > 0;
            zoomIcon.classList.toggle('hidden', !shouldShow);
            if (shouldShow) {
                zoomIcon.innerHTML = isZoomed ? 'üîé' : 'üîç';
                zoomIcon.setAttribute('aria-label', isZoomed ? 'ÿ™ÿµÿ∫Ÿäÿ±' : 'ÿ™ŸÉÿ®Ÿäÿ±');
                zoomIcon.classList.toggle('zoomed', isZoomed);
            }
            if (!shouldShow || !isZoomed) {
                zoomAdjustControls.classList.add('hidden');
            } else {
                zoomAdjustControls.classList.remove('hidden');
            }
        }

        function handleZoomIconClick() {
            if (isDrawing || traceGuides.length === 0) return;
            if (isZoomed) {
                zoomOut();
            } else {
                zoomToStroke(currentPathIndex);
            }
        }

        function handleZoomInAdjust() { adjustZoom('in'); }
        function handleZoomOutAdjust() { adjustZoom('out'); }

        // === Continuous Animated Guide Dot Logic (Modified to handle drawing updates) ===
        function animateGuideDot(timestamp) {
            // Self-scheduling the next frame
            guideDotAnimationId = requestAnimationFrame(animateGuideDot);

            // --- Handle Drawing Path Updates (batched) ---
            if (drawingNeedsUpdate) { // Only update if the flag is set
                drawingPath.setAttribute('d', getFullDrawingPathData());
                drawingNeedsUpdate = false; // Reset flag after updating DOM
            }
            // --- End Drawing Path Updates ---

            // Check if all paths are completed OR if the current path is invalid,
            // then stop animating and clear the dot.
            if (currentPathIndex >= traceGuides.length ||
                !traceGuides[currentPathIndex] ||
                !isValidNumber(pathLengths[currentPathIndex]) || pathLengths[currentPathIndex] <= 0.01) {
                guideDot.style.display = 'none';
                dotAnimationStartTime = null;
                return; // Stop processing dot animation for this frame, but keep rAF loop going for other updates
            }

            const currentPath = traceGuides[currentPathIndex];
            const pathLength = pathLengths[currentPathIndex];

            if (isDrawing) {
                const displayLength = Math.min(pathProgress[currentPathIndex] + 20, pathLength); // Show dot slightly ahead
                if (isValidNumber(displayLength) && displayLength >= 0) {
                    try {
                        const point = currentPath.getPointAtLength(displayLength);
                        if (isValidNumber(point.x) && isValidNumber(point.y)) {
                            guideDot.setAttribute('cx', point.x);
                            guideDot.setAttribute('cy', point.y);
                            guideDot.style.display = 'block';
                        }
                    } catch (e) {
                        console.warn("Error getting point at length during drawing:", e);
                        guideDot.style.display = 'none';
                    }
                }
                dotAnimationStartTime = null; // Reset animation if drawing actively
            } else {
                // If not drawing, animate the dot along the current path from its progress point
                if (!dotAnimationStartTime) dotAnimationStartTime = timestamp;
                const elapsedTime = timestamp - dotAnimationStartTime;

                const startLength = pathProgress[currentPathIndex];
                const endLength = pathLength;
                let segmentLength = endLength - startLength;

                if (!isValidNumber(startLength) || !isValidNumber(endLength) || !isValidNumber(segmentLength) || segmentLength <= 0.01) {
                    guideDot.style.display = 'none';
                    dotAnimationStartTime = null;
                    return;
                }

                const segmentAnimationProgress = (elapsedTime % dotAnimationDuration) / dotAnimationDuration;
                let animatedLength = startLength + (segmentLength * segmentAnimationProgress);

                if (!isValidNumber(animatedLength)) {
                    guideDot.style.display = 'none';
                    dotAnimationStartTime = null;
                    return;
                }

                const clampedLength = Math.max(0, Math.min(animatedLength, endLength - 0.01));

                if (!isValidNumber(clampedLength) || clampedLength < 0) {
                    guideDot.style.display = 'none';
                    dotAnimationStartTime = null;
                    return;
                }

                try {
                    const point = currentPath.getPointAtLength(clampedLength);
                    if (isValidNumber(point.x) && isValidNumber(point.y)) {
                        guideDot.setAttribute('cx', point.x);
                        guideDot.setAttribute('cy', point.y);
                        guideDot.style.display = 'block';
                    }
                } catch (e) {
                    console.warn("Error getting point at length during animation:", e);
                    guideDot.style.display = 'none';
                }
            }
        }

        function stopGuideDotAnimation() {
            if (guideDotAnimationId) {
                cancelAnimationFrame(guideDotAnimationId);
                guideDotAnimationId = null; // Important: Clear the ID so it can be restarted later
            }
            dotAnimationStartTime = null;
            guideDot.style.display = 'none';
            // Ensure any last drawing update is rendered when stopping
            if (drawingNeedsUpdate) {
                drawingPath.setAttribute('d', getFullDrawingPathData());
                drawingNeedsUpdate = false;
            }
        }
        // === End Continuous Animated Guide Dot Logic ===


        function startDrawing(event) {
            if (currentPathIndex >= traceGuides.length) return;

            const userPos = getSVGCoordinates(event);
            const currentPath = traceGuides[currentPathIndex];
            const pathLength = pathLengths[currentPathIndex];

            const initialSnapTolerance = tolerance * 1.5;
            const searchStart = Math.max(0, pathProgress[currentPathIndex] - initialSnapTolerance);
            const searchEnd = Math.min(pathLength, pathProgress[currentPathIndex] + initialSnapTolerance);

            const { point: snappedPoint, length: snappedLength, distance: snappedDistance } =
                getClosestPointOnGuidePath(userPos, currentPath, searchStart, searchEnd);

            if (snappedPoint && snappedDistance <= initialSnapTolerance) {
                isDrawing = true;
                if (snappedLength >= pathProgress[currentPathIndex] - (tolerance / 2)) {
                     pathProgress[currentPathIndex] = snappedLength;
                     drawingNeedsUpdate = true; // Mark for update, will be processed in rAF
                }

                // Only attempt to play if tracing sound is ready, paused, and not muted
                if (tracingSound && tracingSound.readyState >= 2 && tracingSound.paused && !tracingSound.muted) {
                    tracingSound.currentTime = 0;
                    tracingSound.play().catch(e => {
                        // Catch and ignore AbortError, which is common if play() is interrupted by a rapid pause()
                        if (e.name !== "AbortError") {
                            console.error("Error playing tracing sound during play:", e);
                        }
                    });
                } else if (tracingSound && tracingSound.muted) {
                    console.log("Tracing sound is muted, not playing.");
                } else if (tracingSound && tracingSound.readyState < 2) {
                    console.warn("Tracing sound not yet ready or failed to load. ReadyState:", tracingSound.readyState);
                } else if (!tracingSound) {
                    console.error("Tracing sound object not initialized. Check for loading errors.");
                }
            }
        }

        function draw(event) {
            if (!isDrawing) return;
            event.preventDefault();
            if (currentPathIndex >= traceGuides.length) return;

            const userPos = getSVGCoordinates(event);
            const currentPath = traceGuides[currentPathIndex];
            const pathLength = pathLengths[currentPathIndex];

            const lookAheadDistance = 50;
            const searchStart = Math.max(0, pathProgress[currentPathIndex] - (tolerance / 2));
            const searchEnd = Math.min(pathLength, pathProgress[currentPathIndex] + lookAheadDistance);

            const { point: snappedPoint, length: snappedLength, distance: snappedDistance } =
                getClosestPointOnGuidePath(userPos, currentPath, searchStart, searchEnd);

            if (snappedPoint && snappedDistance <= tolerance) {
                const oldProgress = pathProgress[currentPathIndex];
                let newProgress = snappedLength;

                if (newProgress > oldProgress - (tolerance / 4)) {
                    pathProgress[currentPathIndex] = Math.min(pathLength, newProgress);
                    drawingNeedsUpdate = true; // Mark for update
                } else if (newProgress < oldProgress - (tolerance / 2)) {
                    pathProgress[currentPathIndex] = Math.max(0, newProgress);
                    drawingNeedsUpdate = true; // Mark for update
                }


                if (pathProgress[currentPathIndex] >= pathLength - 20) {
                    isDrawing = false;
                    // Only pause if sound is currently playing
                    if (tracingSound && !tracingSound.paused) {
                        tracingSound.pause();
                        tracingSound.currentTime = 0;
                    }

                    drawingNeedsUpdate = true;

                    currentPathIndex++;
                    if (currentPathIndex < traceGuides.length) {
                        dotAnimationStartTime = null;
                        if (isZoomed) {
                            zoomOut(true);
                            setTimeout(() => {
                                zoomToStroke(currentPathIndex, false);
                            }, 150);
                        }
                    } else {
                        stopGuideDotAnimation();
                        drawingNeedsUpdate = true;

                        if (completionSound && completionSound.readyState >= 2) {
                            completionSound.currentTime = 0;
                            completionSound.play().catch(e => console.error("Error playing completion sound during play:", e));
                        } else if (completionSound && completionSound.readyState < 2) {
                            console.warn("Completion sound not yet ready or failed to load. ReadyState:", completionSound.readyState);
                        } else if (!completionSound) {
                            console.error("Completion sound object not initialized. Check for loading errors.");
                        }

                        if (isZoomed) {
                            zoomOut(false);
                            setTimeout(() => {
                                triggerApplauseEffect();
                            }, 200);
                        } else {
                            triggerApplauseEffect();
                        }
                    }
                }
            } else {
                // If user draws too far off the path, stop drawing and sound
                isDrawing = false;
                // Only pause if sound is currently playing
                if (tracingSound && !tracingSound.paused) {
                    tracingSound.pause();
                    tracingSound.currentTime = 0;
                }
                dotAnimationStartTime = null; // Resume normal dot animation
            }
        }

        function stopDrawing() {
            isDrawing = false;
            // Only pause if sound is currently playing
            if (tracingSound && !tracingSound.paused) {
                tracingSound.pause();
                tracingSound.currentTime = 0;
            }
            // Ensure any last drawing update is rendered
            if (drawingNeedsUpdate) {
                drawingPath.setAttribute('d', getFullDrawingPathData());
                drawingNeedsUpdate = false;
            }
            dotAnimationStartTime = null; // Resume dot animation
        }

        function clearDrawing() {
            currentPathIndex = 0;
            pathProgress = Array(traceGuides.length).fill(0);

            drawingPath.setAttribute('d', '');
            drawingNeedsUpdate = false;
            demoButton.disabled = false;

            stopGuideDotAnimation();
            if (guideDotAnimationId === null) {
                 guideDotAnimationId = requestAnimationFrame(animateGuideDot);
            }

            if (tracingSound) {
                if (!tracingSound.paused) {
                    tracingSound.pause();
                    tracingSound.currentTime = 0;
                }
                tracingSound.muted = false;
                if (toggleTracingSoundButton) {
                    toggleTracingSoundButton.innerHTML = 'üîä';
                    toggleTracingSoundButton.setAttribute('aria-label', 'ŸÉÿ™ŸÖ ÿµŸàÿ™ ÿßŸÑÿ™ÿ™ÿ®ÿπ');
                }
            }
            if (completionSound && !completionSound.paused) {
                completionSound.pause();
                completionSound.currentTime = 0;
            }
            if (wordAudio) {
                if (!wordAudio.paused) {
                    wordAudio.pause();
                    wordAudio.currentTime = 0;
                }
                if (playWordAudioButton) {
                    playWordAudioButton.innerHTML = '‚ñ∂Ô∏è';
                    playWordAudioButton.setAttribute('aria-label', 'ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿßŸÑŸÉŸÑŸÖÿ©');
                }
            }

            zoomOut(true);
        }

        function runDemo() {
            clearDrawing();
            demoButton.disabled = true;
            stopGuideDotAnimation();
            guideDot.style.display = 'block';

            zoomOut(true);

            const totalDemoDuration = 15000; // Increased duration for slower demo
            let startTime = null;
            let demoAnimationFrameId = null;

            function animateDemoFrame(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsedTime = timestamp - startTime;
                const progressRatio = Math.min(elapsedTime / totalDemoDuration, 1);

                let totalTotalLength = pathLengths.reduce((acc, len) => acc + len, 0);
                let lengthToCover = totalTotalLength * progressRatio;
                let cumulativeLength = 0;
                let pathData = '';

                for (let i = 0; i < traceGuides.length; i++) {
                    const s_path = traceGuides[i];
                    const s_length = pathLengths[i];

                    const lengthInCurrentPath = Math.max(0, lengthToCover - cumulativeLength);
                    const currentProgressInPath = Math.min(lengthInCurrentPath, s_length);

                    if (currentProgressInPath > 0) {
                        pathData += getPathSegment(s_path, 0, currentProgressInPath) + ' ';
                    }

                    if (lengthToCover >= cumulativeLength && lengthToCover < cumulativeLength + s_length) {
                        try {
                            const point = s_path.getPointAtLength(currentProgressInPath);
                            if (isValidNumber(point.x) && isValidNumber(point.y)) {
                                guideDot.setAttribute('cx', point.x);
                                guideDot.setAttribute('cy', point.y);
                            }
                        } catch (e) {
                            console.warn("Error getting point during demo:", e);
                        }
                    }

                    cumulativeLength += s_length;
                }

                drawingPath.setAttribute('d', pathData.trim());

                if (progressRatio < 1) {
                    demoAnimationFrameId = requestAnimationFrame(animateDemoFrame);
                } else {
                    demoAnimationFrameId = null;
                    demoButton.disabled = false;
                    guideDot.style.display = 'none';
                    clearDrawing();
                }
            }
            demoAnimationFrameId = requestAnimationFrame(animateDemoFrame);
        }

        // === Applause Effect Logic (Confetti) ===
        function triggerApplauseEffect() {
            if (!confettiContainer || !applauseMessage) {
                console.error("Confetti elements not found!");
                return;
            }

            applauseMessage.innerHTML = `
                üéâ ÿπŸÖŸÑ ÿ±ÿßÿ¶ÿπ! üéâ
                <div style="font-size: 0.5em; margin-top: 20px;">ŸÑŸÇÿØ ÿ™ÿ™ÿ®ÿπÿ™ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ!</div>
            `;

            const confettiColors = [
                '#FFC107', '#E91E63', '#9C27B0', '#00BCD4', '#8BC34A', '#FF9800',
                '#FFEB3B', '#F44336', '#673AB7', '#03A9F4', '#CDDC39', '#FF5722',
                '#FF4081', '#7C4DFF', '#4CAF50', '#FFC107', '#009688', '#FF6E40',
                '#FF6347', '#BA55D3', '#00FA9A', '#FFD700', '#20B2AA', '#F08080'
            ];
            const numConfetti = 200;

            confettiContainer.querySelectorAll('.confetti-piece').forEach(piece => piece.remove());

            for (let i = 0; i < numConfetti; i++) {
                const piece = document.createElement('div');
                piece.classList.add('confetti-piece');
                piece.style.backgroundColor = confettiColors[Math.floor(Math.random() * confettiColors.length)];
                piece.style.left = `${Math.random() * 100}vw`;
                piece.style.animationDelay = `${Math.random() * 2}s`;
                piece.style.animationDuration = `${2 + Math.random() * 2}s`;
                confettiContainer.appendChild(piece);
            }

            confettiContainer.classList.add('visible');
            applauseMessage.classList.add('visible');

            setTimeout(() => {
                confettiContainer.classList.remove('visible');
                applauseMessage.classList.remove('visible');
                confettiContainer.innerHTML = '';
                applauseMessage.innerHTML = '';
            }, 3500);
        }
        // === End Applause Effect Logic ===

        // Event Listeners
        svg.addEventListener('mousedown', startDrawing);
        svg.addEventListener('mousemove', draw);
        document.addEventListener('mouseup', stopDrawing);

        svg.addEventListener('touchstart', startDrawing, { passive: false });
        svg.addEventListener('touchmove', draw, { passive: false });
        document.addEventListener('touchend', stopDrawing);

        demoButton.addEventListener('click', runDemo);
        clearButton.addEventListener('click', clearDrawing);

        toggleTracingSoundButton.addEventListener('click', () => {
            if (tracingSound) {
                tracingSound.muted = !tracingSound.muted;
                toggleTracingSoundButton.innerHTML = tracingSound.muted ? 'üîá' : 'üîä';
                toggleTracingSoundButton.setAttribute('aria-label', tracingSound.muted ? 'ÿ•ŸÑÿ∫ÿßÿ° ŸÉÿ™ŸÖ ÿµŸàÿ™ ÿßŸÑÿ™ÿ™ÿ®ÿπ' : 'ŸÉÿ™ŸÖ ÿµŸàÿ™ ÿßŸÑÿ™ÿ™ÿ®ÿπ');
            }
        });

        playWordAudioButton.addEventListener('click', () => {
            if (wordAudio) {
                if (wordAudio.paused) {
                    wordAudio.currentTime = 0;
                    wordAudio.play().then(() => {
                        playWordAudioButton.innerHTML = '‚è∏Ô∏è';
                        playWordAudioButton.setAttribute('aria-label', 'ÿ•ŸäŸÇÿßŸÅ ÿµŸàÿ™ ÿßŸÑŸÉŸÑŸÖÿ© ŸÖÿ§ŸÇÿ™Ÿãÿß');
                    }).catch(e => console.error("Error playing word audio:", e));
                } else {
                    wordAudio.pause();
                    playWordAudioButton.innerHTML = '‚ñ∂Ô∏è';
                    playWordAudioButton.setAttribute('aria-label', 'ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿßŸÑŸÉŸÑŸÖÿ©');
                }
            }
        });

        if (wordAudio) {
            wordAudio.addEventListener('ended', () => {
                playWordAudioButton.innerHTML = '‚ñ∂Ô∏è';
                playWordAudioButton.setAttribute('aria-label', 'ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿßŸÑŸÉŸÑŸÖÿ©');
            });
        }

        zoomIcon.addEventListener('click', handleZoomIconClick);
        zoomInAdjustButton.addEventListener('click', handleZoomInAdjust);
        zoomOutAdjustButton.addEventListener('click', handleZoomOutAdjust);

        // Update positions on window resize/orientation change
        window.addEventListener('resize', () => {
            svgCTM = null; // Clear cached CTM to force recalculation on resize
            updateZoomIconPositionAndVisibility();
            if (isZoomed && currentPathIndex < traceGuides.length) {
                 zoomToStroke(currentPathIndex, true);
            }
        });


        // Initialize on load
        originalViewBox = svg.getAttribute('viewBox') || defaultViewBox;
        // Start the main animation loop only once
        if (guideDotAnimationId === null) {
            guideDotAnimationId = requestAnimationFrame(animateGuideDot);
        }
        updateZoomIconPositionAndVisibility();
    </script>
</body>
</html>
